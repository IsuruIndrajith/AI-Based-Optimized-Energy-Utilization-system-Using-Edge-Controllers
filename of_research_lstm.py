# -*- coding: utf-8 -*-
"""of Research_LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BRWHXUf7DvZ3ab07aqKDRh85aUhFtCWF
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.optimizers import Adam

df = pd.read_csv("/content/final_realistic_appliance_power_data.csv")

if 'Timestamp' in df.columns:
    df.drop(columns=['Timestamp'], inplace=True)

# Normalize the data for all appliance columns
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(df)

def create_sequences(data, seq_length=24):
    x, y = [], []
    for i in range(len(data) - seq_length):
        x.append(data[i:i+seq_length])
        y.append(data[i+seq_length])
    return np.array(x), np.array(y)

x, y = create_sequences(scaled_data, seq_length=24)

x_train, x_temp, y_train, y_temp = train_test_split(x, y, test_size=0.3, random_state=42)
x_val, x_test, y_val, y_test = train_test_split(x_temp, y_temp, test_size=1/3, random_state=42)

model = Sequential()
model.add(LSTM(128, return_sequences=False, input_shape=(x_train.shape[1], x_train.shape[2])))
model.add(Dense(x_train.shape[2]))  # One output per appliance

model.compile(optimizer=Adam(learning_rate=0.001), loss='mse')
model.summary()

history = model.fit(
    x_train, y_train,
    validation_data=(x_val, y_val),
    epochs=50,
    batch_size=32,
    shuffle=False
)

# Plot loss
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.legend()
plt.title("Loss over Epochs")
plt.xlabel("Epoch")
plt.ylabel("MSE Loss")
plt.show()

# Evaluate
mse = model.evaluate(x_test, y_test)
print(f"Test MSE: {mse}")

# Plot loss
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.legend()
plt.title("Loss over Epochs")
plt.xlabel("Epoch")
plt.ylabel("MSE Loss")
plt.show()

# Evaluate
mse = model.evaluate(x_test, y_test)
print(f"Test MSE: {mse}")

# Predict on the test set
y_pred = model.predict(x_test)


y_test_inv = scaler.inverse_transform(y_test)
y_pred_inv = scaler.inverse_transform(y_pred)

appliance_names = df.columns

for i in range(len(appliance_names)):
    plt.figure(figsize=(30, 6))
    plt.plot(y_test_inv[0:100, i], label='Actual')
    plt.plot(y_pred_inv[0:100, i], label='Predicted')
    plt.title(f"{appliance_names[i]} Power Consumption")
    plt.xlabel("Sample")
    plt.ylabel("Power")
    plt.legend()
    plt.grid(True)
    plt.show()

for i in range(len(appliance_names)):
    plt.figure(figsize=(30, 6))
    plt.plot(y_test_inv[200:300, i], label='Actual')
    plt.plot(y_pred_inv[200:300, i], label='Predicted')
    plt.title(f"{appliance_names[i]} Power Consumption")
    plt.xlabel("Sample")
    plt.ylabel("Power")
    plt.legend()
    plt.grid(True)
    plt.show()

model.save('my_lstm_model.h5')
model.save('my_lstm_model.keras')

import pickle

# Save the scaler
with open('scaler.pkl', 'wb') as f:
    pickle.dump(scaler, f)

from tensorflow.keras.models import load_model
import pickle

model = load_model('my_lstm_model.keras')
with open('scaler.pkl', 'rb') as f:
    scaler = pickle.load(f)

x_test_day = x_train[:5000]

# Predict for all sequences in the day at once
all_day_predictions_scaled = model.predict(x_test_day)

# Inverse transform if necessary
all_day_predictions = scaler.inverse_transform(all_day_predictions_scaled)

print("Predicted power consumption for all day:")
print(all_day_predictions)

appliance_names = df.columns
for i, prediction in enumerate(all_day_predictions):
    print(f"Time step {i+1}:")
    for j, appliance in enumerate(appliance_names):
        print(f"  {appliance}: {prediction[j]}")

import numpy as np

def binarize_power_values(power_values, threshold_ratio=0.6):
    """
    Convert continuous power predictions to binary ON/OFF states based on dynamic threshold.

    Parameters:
    - power_values: List or np.array of predicted power values
    - threshold_ratio: Fraction of the max value to determine ON/OFF threshold

    Returns:
    - binary_states: List of 1s (ON) and 0s (OFF)
    """
    power_values = np.array(power_values)
    threshold = threshold_ratio * np.max(power_values)
    binary_states = (power_values >= threshold).astype(int)
    return binary_states

binary_average_states = {}

for appliance_name, avg_values in averages.items():
    # Set different threshold_ratio based on appliance name
    if appliance_name in ['WashingMachine_Power', 'Heater_Power', 'AC_Power']:
        threshold_ratio = 0.6
    else:
        threshold_ratio = 0.8

    binary_states = binarize_power_values(avg_values, threshold_ratio=threshold_ratio)
    binary_average_states[appliance_name] = binary_states

# Print the binarized states for the first few windows for each appliance
for appliance_name, binary_states in binary_average_states.items():
    print(f"--- {appliance_name} Binary States ---")
    print(binary_states[:24])

with open('appliance_data.txt', 'w') as f:
    for appliance_name in appliance_names:
        f.write(f"--- {appliance_name} ---\n")
        f.write("States:\n")

        if appliance_name in states:
            np.savetxt(f, states[appliance_name].reshape(1, -1), fmt='%d', delimiter=', ')
        else:
            f.write("States data not available\n")

        f.write("Averages:\n")

        if appliance_name in averages:
            np.savetxt(f, averages[appliance_name].reshape(1, -1), fmt='%.4f', delimiter=', ')
        else:
            f.write("Averages data not available\n")

        f.write("Binary Average States:\n")

        if appliance_name in binary_average_states:
            np.savetxt(f, binary_average_states[appliance_name].reshape(1, -1), fmt='%d', delimiter=', ')
        else:
            f.write("Binary average states data not available\n")

        f.write("\n")

print("States, averages, and binary average states saved to appliance_data.txt")

file_path = '/content/appliance_data.txt'

try:
    with open(file_path, 'r') as f:
        file_content = f.read()
        print("Contents of the file:")
        print(file_content)
except FileNotFoundError:
    print(f"Error: The file '{file_path}' was not found.")
except Exception as e:
    print(f"An error occurred: {e}")